// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PaymentInstrument payment instrument
//
// swagger:model PaymentInstrument
type PaymentInstrument struct {

	// embedded
	Embedded *PaymentInstrumentEmbedded `json:"_embedded,omitempty"`

	// links
	Links *PaymentInstrumentLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PaymentInstrumentBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PaymentInstrumentBillTo `json:"billTo,omitempty"`

	// buyer information
	BuyerInformation *PaymentInstrumentBuyerInformation `json:"buyerInformation,omitempty"`

	// card
	Card *PaymentInstrumentCard `json:"card,omitempty"`

	// The id of the Payment Instrument Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// instrument identifier
	InstrumentIdentifier *PaymentInstrumentInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// merchant information
	MerchantInformation *PaymentInstrumentMerchantInformation `json:"merchantInformation,omitempty"`

	// metadata
	Metadata *PaymentInstrumentMetadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - paymentInstrument
	//
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PaymentInstrumentProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Read Only: true
	State string `json:"state,omitempty"`
}

// Validate validates this payment instrument
func (m *PaymentInstrument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrument) validateEmbedded(formats strfmt.Registry) error {

	if swag.IsZero(m.Embedded) { // not required
		return nil
	}

	if m.Embedded != nil {
		if err := m.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateBankAccount(formats strfmt.Registry) error {

	if swag.IsZero(m.BankAccount) { // not required
		return nil
	}

	if m.BankAccount != nil {
		if err := m.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bankAccount")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateBillTo(formats strfmt.Registry) error {

	if swag.IsZero(m.BillTo) { // not required
		return nil
	}

	if m.BillTo != nil {
		if err := m.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billTo")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateBuyerInformation(formats strfmt.Registry) error {

	if swag.IsZero(m.BuyerInformation) { // not required
		return nil
	}

	if m.BuyerInformation != nil {
		if err := m.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateCard(formats strfmt.Registry) error {

	if swag.IsZero(m.Card) { // not required
		return nil
	}

	if m.Card != nil {
		if err := m.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateID(formats strfmt.Registry) error {

	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MinLength("id", "body", string(m.ID), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("id", "body", string(m.ID), 32); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrument) validateInstrumentIdentifier(formats strfmt.Registry) error {

	if swag.IsZero(m.InstrumentIdentifier) { // not required
		return nil
	}

	if m.InstrumentIdentifier != nil {
		if err := m.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateMerchantInformation(formats strfmt.Registry) error {

	if swag.IsZero(m.MerchantInformation) { // not required
		return nil
	}

	if m.MerchantInformation != nil {
		if err := m.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateMetadata(formats strfmt.Registry) error {

	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateProcessingInformation(formats strfmt.Registry) error {

	if swag.IsZero(m.ProcessingInformation) { // not required
		return nil
	}

	if m.ProcessingInformation != nil {
		if err := m.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrument) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrument) UnmarshalBinary(b []byte) error {
	var res PaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentBankAccount payment instrument bank account
//
// swagger:model PaymentInstrumentBankAccount
type PaymentInstrumentBankAccount struct {

	// Account type.
	//
	// Valid values:
	//  - checking : C
	//  - general ledger : G This value is supported only on Wells Fargo ACH
	//  - savings : S (U.S. dollars only)
	//  - corporate checking : X (U.S. dollars only)
	//
	// Max Length: 1
	Type string `json:"type,omitempty"`
}

// Validate validates this payment instrument bank account
func (m *PaymentInstrumentBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentBankAccount) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("bankAccount"+"."+"type", "body", string(m.Type), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentBankAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentBankAccount) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentBillTo payment instrument bill to
//
// swagger:model PaymentInstrumentBillTo
type PaymentInstrumentBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer’s records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customer’s company.
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customer’s first name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer’s last name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customer’s phone number.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this payment instrument bill to
func (m *PaymentInstrumentBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentBillTo) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(m.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"address1", "body", string(m.Address1), 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateAddress2(formats strfmt.Registry) error {

	if swag.IsZero(m.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"address2", "body", string(m.Address2), 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(m.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"administrativeArea", "body", string(m.AdministrativeArea), 20); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateCompany(formats strfmt.Registry) error {

	if swag.IsZero(m.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"company", "body", string(m.Company), 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(m.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"country", "body", string(m.Country), 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(m.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"email", "body", string(m.Email), 255); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateFirstName(formats strfmt.Registry) error {

	if swag.IsZero(m.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"firstName", "body", string(m.FirstName), 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateLastName(formats strfmt.Registry) error {

	if swag.IsZero(m.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"lastName", "body", string(m.LastName), 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(m.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"locality", "body", string(m.Locality), 50); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"phoneNumber", "body", string(m.PhoneNumber), 15); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(m.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"postalCode", "body", string(m.PostalCode), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentBillTo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentBillTo) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentBuyerInformation payment instrument buyer information
//
// swagger:model PaymentInstrumentBuyerInformation
type PaymentInstrumentBuyerInformation struct {

	// Company’s tax identifier. This is only used for eCheck service.
	//
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxID,omitempty"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Date of birth of the customer. Format: YYYY-MM-DD
	//
	// Format: date
	DateOfBirth strfmt.Date `json:"dateOfBirth,omitempty"`

	// personal identification
	PersonalIdentification []*PaymentInstrumentBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this payment instrument buyer information
func (m *PaymentInstrumentBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentBuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {

	if swag.IsZero(m.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("buyerInformation"+"."+"companyTaxID", "body", string(m.CompanyTaxID), 9); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBuyerInformation) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("buyerInformation"+"."+"currency", "body", string(m.Currency), 3); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {

	if swag.IsZero(m.DateOfBirth) { // not required
		return nil
	}

	if err := validate.FormatOf("buyerInformation"+"."+"dateOfBirth", "body", "date", m.DateOfBirth.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {

	if swag.IsZero(m.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(m.PersonalIdentification); i++ {
		if swag.IsZero(m.PersonalIdentification[i]) { // not required
			continue
		}

		if m.PersonalIdentification[i] != nil {
			if err := m.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentBuyerInformationPersonalIdentificationItems0 payment instrument buyer information personal identification items0
//
// swagger:model PaymentInstrumentBuyerInformationPersonalIdentificationItems0
type PaymentInstrumentBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// issued by
	IssuedBy *PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Valid values:
	//   - driver license
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this payment instrument buyer information personal identification items0
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssuedBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {

	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", string(m.ID), 26); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0) validateIssuedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.IssuedBy) { // not required
		return nil
	}

	if m.IssuedBy != nil {
		if err := m.IssuedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy payment instrument buyer information personal identification items0 issued by
//
// swagger:model PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy
type PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy struct {

	// The State or province where the customer’s driver’s license was issued.
	//
	// Use the two-character State, Province, and Territory Codes for the United States and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`
}

// Validate validates this payment instrument buyer information personal identification items0 issued by
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(m.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("issuedBy"+"."+"administrativeArea", "body", string(m.AdministrativeArea), 20); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentCard payment instrument card
//
// swagger:model PaymentInstrumentCard
type PaymentInstrumentCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	IssueNumber string `json:"issueNumber,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`.
	// Valid values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// tokenized information
	TokenizedInformation *PaymentInstrumentCardTokenizedInformation `json:"tokenizedInformation,omitempty"`

	// Value that indicates the card type. Valid v2 : v1 - description values:
	//   * 001 : visa
	//   * 002 : mastercard - Eurocard—European regional brand of Mastercard
	//   * 003 : american express
	//   * 004 : discover
	//   * 005 : diners club
	//   * 006 : carte blanche
	//   * 007 : jcb
	//   * 008 : optima
	//   * 011 : twinpay credit
	//   * 012 : twinpay debit
	//   * 013 : walmart
	//   * 014 : enRoute
	//   * 015 : lowes consumer
	//   * 016 : home depot consumer
	//   * 017 : mbna
	//   * 018 : dicks sportswear
	//   * 019 : casual corner
	//   * 020 : sears
	//   * 021 : jal
	//   * 023 : disney
	//   * 024 : maestro uk domestic
	//   * 025 : sams club consumer
	//   * 026 : sams club business
	//   * 028 : bill me later
	//   * 029 : bebe
	//   * 030 : restoration hardware
	//   * 031 : delta online — use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.
	//   * 032 : solo
	//   * 033 : visa electron
	//   * 034 : dankort
	//   * 035 : laser
	//   * 036 : carte bleue — formerly Cartes Bancaires
	//   * 037 : carta si
	//   * 038 : pinless debit
	//   * 039 : encoded account
	//   * 040 : uatp
	//   * 041 : household
	//   * 042 : maestro international
	//   * 043 : ge money uk
	//   * 044 : korean cards
	//   * 045 : style
	//   * 046 : jcrew
	//   * 047 : payease china processing ewallet
	//   * 048 : payease china processing bank transfer
	//   * 049 : meijer private label
	//   * 050 : hipercard — supported only by the Comercio Latino processor.
	//   * 051 : aura — supported only by the Comercio Latino processor.
	//   * 052 : redecard
	//   * 054 : elo — supported only by the Comercio Latino processor.
	//   * 055 : capital one private label
	//   * 056 : synchrony private label
	//   * 057 : costco private label
	//   * 060 : mada
	//   * 062 : china union pay
	//   * 063 : falabella private label
	//
	Type string `json:"type,omitempty"`

	// 'Payment Instrument was created / updated as part of a pinless debit transaction.'
	//
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this payment instrument card
func (m *PaymentInstrumentCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTokenizedInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentCard) validateExpirationMonth(formats strfmt.Registry) error {

	if swag.IsZero(m.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"expirationMonth", "body", string(m.ExpirationMonth), 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentCard) validateExpirationYear(formats strfmt.Registry) error {

	if swag.IsZero(m.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"expirationYear", "body", string(m.ExpirationYear), 4); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentCard) validateIssueNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"issueNumber", "body", string(m.IssueNumber), 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentCard) validateStartMonth(formats strfmt.Registry) error {

	if swag.IsZero(m.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"startMonth", "body", string(m.StartMonth), 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentCard) validateStartYear(formats strfmt.Registry) error {

	if swag.IsZero(m.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"startYear", "body", string(m.StartYear), 4); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentCard) validateTokenizedInformation(formats strfmt.Registry) error {

	if swag.IsZero(m.TokenizedInformation) { // not required
		return nil
	}

	if m.TokenizedInformation != nil {
		if err := m.TokenizedInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentCard) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentCard) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentCardTokenizedInformation payment instrument card tokenized information
//
// swagger:model PaymentInstrumentCardTokenizedInformation
type PaymentInstrumentCardTokenizedInformation struct {

	// Value that identifies your business and indicates that the cardholder’s account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service provider’s database.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 11
	RequestorID string `json:"requestorID,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it
	// specifies the entity that provided you with information about the token.
	//
	// Set the value for this field to 1. An application on the customer’s mobile device provided the token data.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`
}

// Validate validates this payment instrument card tokenized information
func (m *PaymentInstrumentCardTokenizedInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentCardTokenizedInformation) validateRequestorID(formats strfmt.Registry) error {

	if swag.IsZero(m.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"tokenizedInformation"+"."+"requestorID", "body", string(m.RequestorID), 11); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentCardTokenizedInformation) validateTransactionType(formats strfmt.Registry) error {

	if swag.IsZero(m.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"tokenizedInformation"+"."+"transactionType", "body", string(m.TransactionType), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentCardTokenizedInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentCardTokenizedInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentCardTokenizedInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbedded Additional resources for the Payment Instrument token.
//
//
// swagger:model PaymentInstrumentEmbedded
type PaymentInstrumentEmbedded struct {

	// instrument identifier
	InstrumentIdentifier *PaymentInstrumentEmbeddedInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`
}

// Validate validates this payment instrument embedded
func (m *PaymentInstrumentEmbedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbedded) validateInstrumentIdentifier(formats strfmt.Registry) error {

	if swag.IsZero(m.InstrumentIdentifier) { // not required
		return nil
	}

	if m.InstrumentIdentifier != nil {
		if err := m.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbedded) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbedded) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifier payment instrument embedded instrument identifier
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifier
type PaymentInstrumentEmbeddedInstrumentIdentifier struct {

	// links
	Links *PaymentInstrumentEmbeddedInstrumentIdentifierLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PaymentInstrumentEmbeddedInstrumentIdentifierBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PaymentInstrumentEmbeddedInstrumentIdentifierBillTo `json:"billTo,omitempty"`

	// card
	Card *PaymentInstrumentEmbeddedInstrumentIdentifierCard `json:"card,omitempty"`

	// The id of the Instrument Identifier Token.
	//
	ID string `json:"id,omitempty"`

	// issuer
	Issuer *PaymentInstrumentEmbeddedInstrumentIdentifierIssuer `json:"issuer,omitempty"`

	// metadata
	Metadata *PaymentInstrumentEmbeddedInstrumentIdentifierMetadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - instrumentIdentifier
	//
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Read Only: true
	State string `json:"state,omitempty"`

	// tokenized card
	TokenizedCard *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard `json:"tokenizedCard,omitempty"`

	// The type of Instrument Identifier.
	// Valid values:
	// - enrollable card
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier
func (m *PaymentInstrumentEmbeddedInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifier) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifier) validateBankAccount(formats strfmt.Registry) error {

	if swag.IsZero(m.BankAccount) { // not required
		return nil
	}

	if m.BankAccount != nil {
		if err := m.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifier) validateBillTo(formats strfmt.Registry) error {

	if swag.IsZero(m.BillTo) { // not required
		return nil
	}

	if m.BillTo != nil {
		if err := m.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifier) validateCard(formats strfmt.Registry) error {

	if swag.IsZero(m.Card) { // not required
		return nil
	}

	if m.Card != nil {
		if err := m.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifier) validateIssuer(formats strfmt.Registry) error {

	if swag.IsZero(m.Issuer) { // not required
		return nil
	}

	if m.Issuer != nil {
		if err := m.Issuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifier) validateMetadata(formats strfmt.Registry) error {

	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifier) validateProcessingInformation(formats strfmt.Registry) error {

	if swag.IsZero(m.ProcessingInformation) { // not required
		return nil
	}

	if m.ProcessingInformation != nil {
		if err := m.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifier) validateTokenizedCard(formats strfmt.Registry) error {

	if swag.IsZero(m.TokenizedCard) { // not required
		return nil
	}

	if m.TokenizedCard != nil {
		if err := m.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierBankAccount payment instrument embedded instrument identifier bank account
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierBankAccount
type PaymentInstrumentEmbeddedInstrumentIdentifierBankAccount struct {

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Bank routing number. This is also called the transit number.
	//
	// For details, see `ecp_rdfi` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier bank account
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) validateNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", string(m.Number), 17); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierBillTo This information is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierBillTo
type PaymentInstrumentEmbeddedInstrumentIdentifierBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer’s records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier bill to
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(m.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address1", "body", string(m.Address1), 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateAddress2(formats strfmt.Registry) error {

	if swag.IsZero(m.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address2", "body", string(m.Address2), 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(m.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"administrativeArea", "body", string(m.AdministrativeArea), 20); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(m.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"country", "body", string(m.Country), 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(m.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"locality", "body", string(m.Locality), 50); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(m.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"postalCode", "body", string(m.PostalCode), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBillTo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierBillTo) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierCard The expirationMonth, expirationYear and securityCode is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierCard
type PaymentInstrumentEmbeddedInstrumentIdentifierCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// Max Length: 19
	// Min Length: 12
	Number string `json:"number,omitempty"`

	// Card Verification Number.
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier card
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierCard) validateExpirationMonth(formats strfmt.Registry) error {

	if swag.IsZero(m.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationMonth", "body", string(m.ExpirationMonth), 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierCard) validateExpirationYear(formats strfmt.Registry) error {

	if swag.IsZero(m.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationYear", "body", string(m.ExpirationYear), 4); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierCard) validateNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.Number) { // not required
		return nil
	}

	if err := validate.MinLength("_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", string(m.Number), 12); err != nil {
		return err
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", string(m.Number), 19); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierCard) validateSecurityCode(formats strfmt.Registry) error {

	if swag.IsZero(m.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"securityCode", "body", string(m.SecurityCode), 4); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierCard) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierCard) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierIssuer payment instrument embedded instrument identifier issuer
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierIssuer
type PaymentInstrumentEmbeddedInstrumentIdentifierIssuer struct {

	// This reference number serves as a link to the cardholder account and to all transactions for that account.
	//
	// Read Only: true
	// Max Length: 32
	PaymentAccountReference string `json:"paymentAccountReference,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier issuer
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePaymentAccountReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierIssuer) validatePaymentAccountReference(formats strfmt.Registry) error {

	if swag.IsZero(m.PaymentAccountReference) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", string(m.PaymentAccountReference), 32); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierIssuer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierIssuer) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierLinks payment instrument embedded instrument identifier links
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierLinks
type PaymentInstrumentEmbeddedInstrumentIdentifierLinks struct {

	// payment instruments
	PaymentInstruments *PaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments `json:"paymentInstruments,omitempty"`

	// self
	Self *PaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf `json:"self,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier links
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierLinks) validatePaymentInstruments(formats strfmt.Registry) error {

	if swag.IsZero(m.PaymentInstruments) { // not required
		return nil
	}

	if m.PaymentInstruments != nil {
		if err := m.PaymentInstruments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierLinks) validateSelf(formats strfmt.Registry) error {

	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierLinks) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments payment instrument embedded instrument identifier links payment instruments
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments
type PaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments struct {

	// Link to the Instrument Identifiers Payment Instruments.
	//
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier links payment instruments
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf payment instrument embedded instrument identifier links self
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf
type PaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf struct {

	// Link to the Instrument Identifier.
	//
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier links self
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierMetadata payment instrument embedded instrument identifier metadata
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierMetadata
type PaymentInstrumentEmbeddedInstrumentIdentifierMetadata struct {

	// The creator of the Instrument Identifier token.
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier metadata
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierMetadata) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation payment instrument embedded instrument identifier processing information
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation
type PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation struct {

	// authorization options
	AuthorizationOptions *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier processing information
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthorizationOptions) { // not required
		return nil
	}

	if m.AuthorizationOptions != nil {
		if err := m.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions payment instrument embedded instrument identifier processing information authorization options
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
type PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier processing information authorization options
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {

	if swag.IsZero(m.Initiator) { // not required
		return nil
	}

	if m.Initiator != nil {
		if err := m.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator payment instrument embedded instrument identifier processing information authorization options initiator
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
type PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator struct {

	// merchant initiated transaction
	MerchantInitiatedTransaction *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier processing information authorization options initiator
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {

	if swag.IsZero(m.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if m.MerchantInitiatedTransaction != nil {
		if err := m.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction payment instrument embedded instrument identifier processing information authorization options initiator merchant initiated transaction
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
type PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_
	// in the reply message for either the original merchant-initiated payment in the series or the previous
	// merchant-initiated payment in the series.
	//
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier processing information authorization options initiator merchant initiated transaction
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(m.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", string(m.PreviousTransactionID), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard payment instrument embedded instrument identifier tokenized card
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard
type PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard struct {

	// card
	Card *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard `json:"card,omitempty"`

	// Generated value used in conjunction with the network token for making a payment.
	//
	// Read Only: true
	Cryptogram string `json:"cryptogram,omitempty"`

	// Two-digit month in which the network token expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the network token expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The token requestors customer’s payment network token
	//
	// Read Only: true
	Number string `json:"number,omitempty"`

	// Issuers state for the network token
	// Valid values:
	// - ACTIVE
	// - SUSPENDED : This state can change to ACTIVE or DELETED.
	// - DELETED : This is a final state for the network token.
	//
	// Read Only: true
	State string `json:"state,omitempty"`

	// The network token card association brand
	// Valid values:
	// - visa
	// - mastercard
	//
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier tokenized card
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) validateCard(formats strfmt.Registry) error {

	if swag.IsZero(m.Card) { // not required
		return nil
	}

	if m.Card != nil {
		if err := m.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {

	if swag.IsZero(m.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", string(m.ExpirationMonth), 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {

	if swag.IsZero(m.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", string(m.ExpirationYear), 4); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard The latest card details associated with the network token
//
// swagger:model PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard
type PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard struct {

	//
	// Two-digit month in which the customer’s latest payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the customer’s latest payment card expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customer’s latest payment card number suffix
	//
	// Read Only: true
	Suffix string `json:"suffix,omitempty"`
}

// Validate validates this payment instrument embedded instrument identifier tokenized card card
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationMonth(formats strfmt.Registry) error {

	if swag.IsZero(m.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", string(m.ExpirationMonth), 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationYear(formats strfmt.Registry) error {

	if swag.IsZero(m.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", string(m.ExpirationYear), 4); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifier payment instrument instrument identifier
//
// swagger:model PaymentInstrumentInstrumentIdentifier
type PaymentInstrumentInstrumentIdentifier struct {

	// The id of the Instrument Identifier token linked to the Payment Instrument.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`
}

// Validate validates this payment instrument instrument identifier
func (m *PaymentInstrumentInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) validateID(formats strfmt.Registry) error {

	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MinLength("instrumentIdentifier"+"."+"id", "body", string(m.ID), 12); err != nil {
		return err
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"id", "body", string(m.ID), 32); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentLinks payment instrument links
//
// swagger:model PaymentInstrumentLinks
type PaymentInstrumentLinks struct {

	// customer
	Customer *PaymentInstrumentLinksCustomer `json:"customer,omitempty"`

	// self
	Self *PaymentInstrumentLinksSelf `json:"self,omitempty"`
}

// Validate validates this payment instrument links
func (m *PaymentInstrumentLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentLinks) validateCustomer(formats strfmt.Registry) error {

	if swag.IsZero(m.Customer) { // not required
		return nil
	}

	if m.Customer != nil {
		if err := m.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentLinks) validateSelf(formats strfmt.Registry) error {

	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentLinks) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentLinksCustomer payment instrument links customer
//
// swagger:model PaymentInstrumentLinksCustomer
type PaymentInstrumentLinksCustomer struct {

	// Link to the Customer.
	//
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instrument links customer
func (m *PaymentInstrumentLinksCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentLinksCustomer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentLinksCustomer) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentLinksCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentLinksSelf payment instrument links self
//
// swagger:model PaymentInstrumentLinksSelf
type PaymentInstrumentLinksSelf struct {

	// Link to the Payment Instrument.
	//
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instrument links self
func (m *PaymentInstrumentLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentLinksSelf) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentLinksSelf) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentMerchantInformation payment instrument merchant information
//
// swagger:model PaymentInstrumentMerchantInformation
type PaymentInstrumentMerchantInformation struct {

	// merchant descriptor
	MerchantDescriptor *PaymentInstrumentMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`
}

// Validate validates this payment instrument merchant information
func (m *PaymentInstrumentMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {

	if swag.IsZero(m.MerchantDescriptor) { // not required
		return nil
	}

	if m.MerchantDescriptor != nil {
		if err := m.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentMerchantInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentMerchantInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentMerchantInformationMerchantDescriptor payment instrument merchant information merchant descriptor
//
// swagger:model PaymentInstrumentMerchantInformationMerchantDescriptor
type PaymentInstrumentMerchantInformationMerchantDescriptor struct {

	// Alternate contact information for your business,such as an email address or URL.
	// This value might be displayed on the cardholder’s statement.
	// When you do not include this value in your capture or credit request, CyberSource uses the merchant URL from your CyberSource account.
	// Important This value must consist of English characters
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`
}

// Validate validates this payment instrument merchant information merchant descriptor
func (m *PaymentInstrumentMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {

	if swag.IsZero(m.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", string(m.AlternateName), 13); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentMetadata payment instrument metadata
//
// swagger:model PaymentInstrumentMetadata
type PaymentInstrumentMetadata struct {

	// The creator of the Payment Instrument token.
	//
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this payment instrument metadata
func (m *PaymentInstrumentMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentMetadata) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentProcessingInformation payment instrument processing information
//
// swagger:model PaymentInstrumentProcessingInformation
type PaymentInstrumentProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *PaymentInstrumentProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Flag that indicates that this is a payment for a bill or for an existing contractual loan.
	// For processor-specific details, see the `bill_payment` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Valid values:
	// - `true`: Bill payment or loan payment.
	// - `false` (default): Not a bill payment or loan payment.
	//
	BillPaymentProgramEnabled bool `json:"billPaymentProgramEnabled,omitempty"`
}

// Validate validates this payment instrument processing information
func (m *PaymentInstrumentProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.BankTransferOptions) { // not required
		return nil
	}

	if m.BankTransferOptions != nil {
		if err := m.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentProcessingInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentProcessingInformationBankTransferOptions payment instrument processing information bank transfer options
//
// swagger:model PaymentInstrumentProcessingInformationBankTransferOptions
type PaymentInstrumentProcessingInformationBankTransferOptions struct {

	// Specifies the authorization method for the transaction.
	//
	// #### TeleCheck
	// Valid values:
	// - `ARC`: account receivable conversion
	// - `CCD`: corporate cash disbursement
	// - `POP`: point of purchase conversion
	// - `PPD`: prearranged payment and deposit entry
	// - `TEL`: telephone-initiated entry
	// - `WEB`: internet-initiated entry
	//
	// For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 3
	SECCode string `json:"SECCode,omitempty"`
}

// Validate validates this payment instrument processing information bank transfer options
func (m *PaymentInstrumentProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSECCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentProcessingInformationBankTransferOptions) validateSECCode(formats strfmt.Registry) error {

	if swag.IsZero(m.SECCode) { // not required
		return nil
	}

	if err := validate.MaxLength("processingInformation"+"."+"bankTransferOptions"+"."+"SECCode", "body", string(m.SECCode), 3); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
